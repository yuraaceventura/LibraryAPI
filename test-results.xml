<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="16" failures="0" skipped="0" tests="16" time="54.925" timestamp="2025-10-28T21:25:24.013627+03:00" hostname="yura"><testcase classname="tests.test_auth" name="test_unauthed_login" time="2.755"><error message="failed on setup with &quot;socket.gaierror: [Errno 11001] getaddrinfo failed&quot;">self = &lt;Coroutine test_unauthed_login&gt;

    def setup(self) -&gt; None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
&gt;       return super().setup()
               ^^^^^^^^^^^^^^^

.venv\Lib\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
                  ^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests\conftest.py:14: in setup_db
    async with engine.begin() as conn:
               ^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\contextlib.py:214: in __aenter__
    return await anext(self.gen)
           ^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:1066: in begin
    async with conn:
               ^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\base.py:121: in __aenter__
    return await self.start(is_ctxmanager=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:274: in start
    await greenlet_spawn(self.sync_engine.connect)
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3273: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3297: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:449: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:713: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:179: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:177: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:390: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:675: in __init__
    self.__connect()
.venv\Lib\site-packages\sqlalchemy\pool\base.py:901: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\base.py:897: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\create.py:646: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\default.py:625: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:961: in connect
    await_only(creator_fn(*arg, **kw)),
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connection.py:2421: in connect
    return await connect_utils._connect(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1075: in _connect
    raise last_error or exceptions.TargetServerAttributeNotMatched(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1049: in _connect
    conn = await _connect_addr(
.venv\Lib\site-packages\asyncpg\connect_utils.py:886: in _connect_addr
    return await __connect_addr(params, True, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:931: in __connect_addr
    tr, pr = await connector
             ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:802: in _create_ssl_connection
    tr, pr = await loop.create_connection(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1122: in create_connection
    infos = await self._ensure_resolved(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1508: in _ensure_resolved
    return await loop.getaddrinfo(host, port, family=family, type=type,
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:939: in getaddrinfo
    return await self.run_in_executor(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

host = 'db', port = 5432, family = 0, type = &lt;SocketKind.SOCK_STREAM: 1&gt;, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
&gt;       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       socket.gaierror: [Errno 11001] getaddrinfo failed

C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\socket.py:977: gaierror</error></testcase><testcase classname="tests.test_auth" name="test_authed_login" time="2.700"><error message="failed on setup with &quot;socket.gaierror: [Errno 11001] getaddrinfo failed&quot;">self = &lt;Coroutine test_authed_login&gt;

    def setup(self) -&gt; None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
&gt;       return super().setup()
               ^^^^^^^^^^^^^^^

.venv\Lib\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
                  ^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests\conftest.py:14: in setup_db
    async with engine.begin() as conn:
               ^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\contextlib.py:214: in __aenter__
    return await anext(self.gen)
           ^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:1066: in begin
    async with conn:
               ^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\base.py:121: in __aenter__
    return await self.start(is_ctxmanager=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:274: in start
    await greenlet_spawn(self.sync_engine.connect)
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3273: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3297: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:449: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:713: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:179: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:177: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:390: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:675: in __init__
    self.__connect()
.venv\Lib\site-packages\sqlalchemy\pool\base.py:901: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\base.py:897: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\create.py:646: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\default.py:625: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:961: in connect
    await_only(creator_fn(*arg, **kw)),
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connection.py:2421: in connect
    return await connect_utils._connect(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1075: in _connect
    raise last_error or exceptions.TargetServerAttributeNotMatched(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1049: in _connect
    conn = await _connect_addr(
.venv\Lib\site-packages\asyncpg\connect_utils.py:886: in _connect_addr
    return await __connect_addr(params, True, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:931: in __connect_addr
    tr, pr = await connector
             ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:802: in _create_ssl_connection
    tr, pr = await loop.create_connection(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1122: in create_connection
    infos = await self._ensure_resolved(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1508: in _ensure_resolved
    return await loop.getaddrinfo(host, port, family=family, type=type,
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:939: in getaddrinfo
    return await self.run_in_executor(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

host = 'db', port = 5432, family = 0, type = &lt;SocketKind.SOCK_STREAM: 1&gt;, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
&gt;       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       socket.gaierror: [Errno 11001] getaddrinfo failed

C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\socket.py:977: gaierror</error></testcase><testcase classname="tests.test_books.TestBooksEndpoints" name="test_get_books_empty" time="2.689"><error message="failed on setup with &quot;socket.gaierror: [Errno 11001] getaddrinfo failed&quot;">self = &lt;Coroutine test_get_books_empty&gt;

    def setup(self) -&gt; None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
&gt;       return super().setup()
               ^^^^^^^^^^^^^^^

.venv\Lib\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
                  ^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests\conftest.py:14: in setup_db
    async with engine.begin() as conn:
               ^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\contextlib.py:214: in __aenter__
    return await anext(self.gen)
           ^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:1066: in begin
    async with conn:
               ^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\base.py:121: in __aenter__
    return await self.start(is_ctxmanager=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:274: in start
    await greenlet_spawn(self.sync_engine.connect)
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3273: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3297: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:449: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:713: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:179: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:177: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:390: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:675: in __init__
    self.__connect()
.venv\Lib\site-packages\sqlalchemy\pool\base.py:901: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\base.py:897: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\create.py:646: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\default.py:625: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:961: in connect
    await_only(creator_fn(*arg, **kw)),
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connection.py:2421: in connect
    return await connect_utils._connect(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1075: in _connect
    raise last_error or exceptions.TargetServerAttributeNotMatched(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1049: in _connect
    conn = await _connect_addr(
.venv\Lib\site-packages\asyncpg\connect_utils.py:886: in _connect_addr
    return await __connect_addr(params, True, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:931: in __connect_addr
    tr, pr = await connector
             ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:802: in _create_ssl_connection
    tr, pr = await loop.create_connection(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1122: in create_connection
    infos = await self._ensure_resolved(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1508: in _ensure_resolved
    return await loop.getaddrinfo(host, port, family=family, type=type,
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:939: in getaddrinfo
    return await self.run_in_executor(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

host = 'db', port = 5432, family = 0, type = &lt;SocketKind.SOCK_STREAM: 1&gt;, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
&gt;       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       socket.gaierror: [Errno 11001] getaddrinfo failed

C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\socket.py:977: gaierror</error></testcase><testcase classname="tests.test_books.TestBooksEndpoints" name="test_create_book_success" time="2.710"><error message="failed on setup with &quot;socket.gaierror: [Errno 11001] getaddrinfo failed&quot;">self = &lt;Coroutine test_create_book_success&gt;

    def setup(self) -&gt; None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
&gt;       return super().setup()
               ^^^^^^^^^^^^^^^

.venv\Lib\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
                  ^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests\conftest.py:14: in setup_db
    async with engine.begin() as conn:
               ^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\contextlib.py:214: in __aenter__
    return await anext(self.gen)
           ^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:1066: in begin
    async with conn:
               ^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\base.py:121: in __aenter__
    return await self.start(is_ctxmanager=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:274: in start
    await greenlet_spawn(self.sync_engine.connect)
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3273: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3297: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:449: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:713: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:179: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:177: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:390: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:675: in __init__
    self.__connect()
.venv\Lib\site-packages\sqlalchemy\pool\base.py:901: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\base.py:897: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\create.py:646: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\default.py:625: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:961: in connect
    await_only(creator_fn(*arg, **kw)),
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connection.py:2421: in connect
    return await connect_utils._connect(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1075: in _connect
    raise last_error or exceptions.TargetServerAttributeNotMatched(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1049: in _connect
    conn = await _connect_addr(
.venv\Lib\site-packages\asyncpg\connect_utils.py:886: in _connect_addr
    return await __connect_addr(params, True, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:931: in __connect_addr
    tr, pr = await connector
             ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:802: in _create_ssl_connection
    tr, pr = await loop.create_connection(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1122: in create_connection
    infos = await self._ensure_resolved(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1508: in _ensure_resolved
    return await loop.getaddrinfo(host, port, family=family, type=type,
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:939: in getaddrinfo
    return await self.run_in_executor(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

host = 'db', port = 5432, family = 0, type = &lt;SocketKind.SOCK_STREAM: 1&gt;, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
&gt;       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       socket.gaierror: [Errno 11001] getaddrinfo failed

C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\socket.py:977: gaierror</error></testcase><testcase classname="tests.test_books.TestBooksEndpoints" name="test_get_book_by_id[1-200]" time="2.714"><error message="failed on setup with &quot;socket.gaierror: [Errno 11001] getaddrinfo failed&quot;">self = &lt;Coroutine test_get_book_by_id[1-200]&gt;

    def setup(self) -&gt; None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
&gt;       return super().setup()
               ^^^^^^^^^^^^^^^

.venv\Lib\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
                  ^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests\conftest.py:14: in setup_db
    async with engine.begin() as conn:
               ^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\contextlib.py:214: in __aenter__
    return await anext(self.gen)
           ^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:1066: in begin
    async with conn:
               ^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\base.py:121: in __aenter__
    return await self.start(is_ctxmanager=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:274: in start
    await greenlet_spawn(self.sync_engine.connect)
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3273: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3297: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:449: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:713: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:179: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:177: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:390: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:675: in __init__
    self.__connect()
.venv\Lib\site-packages\sqlalchemy\pool\base.py:901: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\base.py:897: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\create.py:646: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\default.py:625: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:961: in connect
    await_only(creator_fn(*arg, **kw)),
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connection.py:2421: in connect
    return await connect_utils._connect(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1075: in _connect
    raise last_error or exceptions.TargetServerAttributeNotMatched(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1049: in _connect
    conn = await _connect_addr(
.venv\Lib\site-packages\asyncpg\connect_utils.py:886: in _connect_addr
    return await __connect_addr(params, True, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:931: in __connect_addr
    tr, pr = await connector
             ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:802: in _create_ssl_connection
    tr, pr = await loop.create_connection(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1122: in create_connection
    infos = await self._ensure_resolved(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1508: in _ensure_resolved
    return await loop.getaddrinfo(host, port, family=family, type=type,
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:939: in getaddrinfo
    return await self.run_in_executor(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

host = 'db', port = 5432, family = 0, type = &lt;SocketKind.SOCK_STREAM: 1&gt;, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
&gt;       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       socket.gaierror: [Errno 11001] getaddrinfo failed

C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\socket.py:977: gaierror</error></testcase><testcase classname="tests.test_books.TestBooksEndpoints" name="test_get_book_by_id[999-404]" time="2.693"><error message="failed on setup with &quot;socket.gaierror: [Errno 11001] getaddrinfo failed&quot;">self = &lt;Coroutine test_get_book_by_id[999-404]&gt;

    def setup(self) -&gt; None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
&gt;       return super().setup()
               ^^^^^^^^^^^^^^^

.venv\Lib\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
                  ^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests\conftest.py:14: in setup_db
    async with engine.begin() as conn:
               ^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\contextlib.py:214: in __aenter__
    return await anext(self.gen)
           ^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:1066: in begin
    async with conn:
               ^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\base.py:121: in __aenter__
    return await self.start(is_ctxmanager=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:274: in start
    await greenlet_spawn(self.sync_engine.connect)
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3273: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3297: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:449: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:713: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:179: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:177: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:390: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:675: in __init__
    self.__connect()
.venv\Lib\site-packages\sqlalchemy\pool\base.py:901: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\base.py:897: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\create.py:646: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\default.py:625: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:961: in connect
    await_only(creator_fn(*arg, **kw)),
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connection.py:2421: in connect
    return await connect_utils._connect(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1075: in _connect
    raise last_error or exceptions.TargetServerAttributeNotMatched(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1049: in _connect
    conn = await _connect_addr(
.venv\Lib\site-packages\asyncpg\connect_utils.py:886: in _connect_addr
    return await __connect_addr(params, True, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:931: in __connect_addr
    tr, pr = await connector
             ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:802: in _create_ssl_connection
    tr, pr = await loop.create_connection(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1122: in create_connection
    infos = await self._ensure_resolved(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1508: in _ensure_resolved
    return await loop.getaddrinfo(host, port, family=family, type=type,
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:939: in getaddrinfo
    return await self.run_in_executor(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

host = 'db', port = 5432, family = 0, type = &lt;SocketKind.SOCK_STREAM: 1&gt;, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
&gt;       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       socket.gaierror: [Errno 11001] getaddrinfo failed

C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\socket.py:977: gaierror</error></testcase><testcase classname="tests.test_books.TestBooksEndpoints" name="test_delete_book[1-200]" time="2.691"><error message="failed on setup with &quot;socket.gaierror: [Errno 11001] getaddrinfo failed&quot;">self = &lt;Coroutine test_delete_book[1-200]&gt;

    def setup(self) -&gt; None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
&gt;       return super().setup()
               ^^^^^^^^^^^^^^^

.venv\Lib\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
                  ^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests\conftest.py:14: in setup_db
    async with engine.begin() as conn:
               ^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\contextlib.py:214: in __aenter__
    return await anext(self.gen)
           ^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:1066: in begin
    async with conn:
               ^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\base.py:121: in __aenter__
    return await self.start(is_ctxmanager=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:274: in start
    await greenlet_spawn(self.sync_engine.connect)
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3273: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3297: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:449: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:713: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:179: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:177: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:390: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:675: in __init__
    self.__connect()
.venv\Lib\site-packages\sqlalchemy\pool\base.py:901: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\base.py:897: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\create.py:646: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\default.py:625: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:961: in connect
    await_only(creator_fn(*arg, **kw)),
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connection.py:2421: in connect
    return await connect_utils._connect(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1075: in _connect
    raise last_error or exceptions.TargetServerAttributeNotMatched(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1049: in _connect
    conn = await _connect_addr(
.venv\Lib\site-packages\asyncpg\connect_utils.py:886: in _connect_addr
    return await __connect_addr(params, True, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:931: in __connect_addr
    tr, pr = await connector
             ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:802: in _create_ssl_connection
    tr, pr = await loop.create_connection(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1122: in create_connection
    infos = await self._ensure_resolved(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1508: in _ensure_resolved
    return await loop.getaddrinfo(host, port, family=family, type=type,
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:939: in getaddrinfo
    return await self.run_in_executor(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

host = 'db', port = 5432, family = 0, type = &lt;SocketKind.SOCK_STREAM: 1&gt;, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
&gt;       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       socket.gaierror: [Errno 11001] getaddrinfo failed

C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\socket.py:977: gaierror</error></testcase><testcase classname="tests.test_books.TestBooksEndpoints" name="test_delete_book[999-404]" time="2.731"><error message="failed on setup with &quot;socket.gaierror: [Errno 11001] getaddrinfo failed&quot;">self = &lt;Coroutine test_delete_book[999-404]&gt;

    def setup(self) -&gt; None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
&gt;       return super().setup()
               ^^^^^^^^^^^^^^^

.venv\Lib\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
                  ^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests\conftest.py:14: in setup_db
    async with engine.begin() as conn:
               ^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\contextlib.py:214: in __aenter__
    return await anext(self.gen)
           ^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:1066: in begin
    async with conn:
               ^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\base.py:121: in __aenter__
    return await self.start(is_ctxmanager=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:274: in start
    await greenlet_spawn(self.sync_engine.connect)
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3273: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3297: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:449: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:713: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:179: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:177: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:390: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:675: in __init__
    self.__connect()
.venv\Lib\site-packages\sqlalchemy\pool\base.py:901: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\base.py:897: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\create.py:646: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\default.py:625: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:961: in connect
    await_only(creator_fn(*arg, **kw)),
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connection.py:2421: in connect
    return await connect_utils._connect(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1075: in _connect
    raise last_error or exceptions.TargetServerAttributeNotMatched(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1049: in _connect
    conn = await _connect_addr(
.venv\Lib\site-packages\asyncpg\connect_utils.py:886: in _connect_addr
    return await __connect_addr(params, True, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:931: in __connect_addr
    tr, pr = await connector
             ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:802: in _create_ssl_connection
    tr, pr = await loop.create_connection(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1122: in create_connection
    infos = await self._ensure_resolved(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1508: in _ensure_resolved
    return await loop.getaddrinfo(host, port, family=family, type=type,
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:939: in getaddrinfo
    return await self.run_in_executor(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

host = 'db', port = 5432, family = 0, type = &lt;SocketKind.SOCK_STREAM: 1&gt;, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
&gt;       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       socket.gaierror: [Errno 11001] getaddrinfo failed

C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\socket.py:977: gaierror</error></testcase><testcase classname="tests.test_books.TestBooksEndpoints" name="test_update_book[update_data0-200]" time="2.713"><error message="failed on setup with &quot;socket.gaierror: [Errno 11001] getaddrinfo failed&quot;">self = &lt;Coroutine test_update_book[update_data0-200]&gt;

    def setup(self) -&gt; None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
&gt;       return super().setup()
               ^^^^^^^^^^^^^^^

.venv\Lib\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
                  ^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests\conftest.py:14: in setup_db
    async with engine.begin() as conn:
               ^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\contextlib.py:214: in __aenter__
    return await anext(self.gen)
           ^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:1066: in begin
    async with conn:
               ^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\base.py:121: in __aenter__
    return await self.start(is_ctxmanager=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:274: in start
    await greenlet_spawn(self.sync_engine.connect)
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3273: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3297: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:449: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:713: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:179: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:177: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:390: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:675: in __init__
    self.__connect()
.venv\Lib\site-packages\sqlalchemy\pool\base.py:901: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\base.py:897: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\create.py:646: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\default.py:625: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:961: in connect
    await_only(creator_fn(*arg, **kw)),
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connection.py:2421: in connect
    return await connect_utils._connect(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1075: in _connect
    raise last_error or exceptions.TargetServerAttributeNotMatched(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1049: in _connect
    conn = await _connect_addr(
.venv\Lib\site-packages\asyncpg\connect_utils.py:886: in _connect_addr
    return await __connect_addr(params, True, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:931: in __connect_addr
    tr, pr = await connector
             ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:802: in _create_ssl_connection
    tr, pr = await loop.create_connection(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1122: in create_connection
    infos = await self._ensure_resolved(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1508: in _ensure_resolved
    return await loop.getaddrinfo(host, port, family=family, type=type,
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:939: in getaddrinfo
    return await self.run_in_executor(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

host = 'db', port = 5432, family = 0, type = &lt;SocketKind.SOCK_STREAM: 1&gt;, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
&gt;       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       socket.gaierror: [Errno 11001] getaddrinfo failed

C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\socket.py:977: gaierror</error></testcase><testcase classname="tests.test_books.TestBooksEndpoints" name="test_update_book[update_data1-409]" time="2.721"><error message="failed on setup with &quot;socket.gaierror: [Errno 11001] getaddrinfo failed&quot;">self = &lt;Coroutine test_update_book[update_data1-409]&gt;

    def setup(self) -&gt; None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
&gt;       return super().setup()
               ^^^^^^^^^^^^^^^

.venv\Lib\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
                  ^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests\conftest.py:14: in setup_db
    async with engine.begin() as conn:
               ^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\contextlib.py:214: in __aenter__
    return await anext(self.gen)
           ^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:1066: in begin
    async with conn:
               ^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\base.py:121: in __aenter__
    return await self.start(is_ctxmanager=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:274: in start
    await greenlet_spawn(self.sync_engine.connect)
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3273: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3297: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:449: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:713: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:179: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:177: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:390: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:675: in __init__
    self.__connect()
.venv\Lib\site-packages\sqlalchemy\pool\base.py:901: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\base.py:897: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\create.py:646: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\default.py:625: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:961: in connect
    await_only(creator_fn(*arg, **kw)),
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connection.py:2421: in connect
    return await connect_utils._connect(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1075: in _connect
    raise last_error or exceptions.TargetServerAttributeNotMatched(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1049: in _connect
    conn = await _connect_addr(
.venv\Lib\site-packages\asyncpg\connect_utils.py:886: in _connect_addr
    return await __connect_addr(params, True, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:931: in __connect_addr
    tr, pr = await connector
             ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:802: in _create_ssl_connection
    tr, pr = await loop.create_connection(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1122: in create_connection
    infos = await self._ensure_resolved(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1508: in _ensure_resolved
    return await loop.getaddrinfo(host, port, family=family, type=type,
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:939: in getaddrinfo
    return await self.run_in_executor(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

host = 'db', port = 5432, family = 0, type = &lt;SocketKind.SOCK_STREAM: 1&gt;, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
&gt;       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       socket.gaierror: [Errno 11001] getaddrinfo failed

C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\socket.py:977: gaierror</error></testcase><testcase classname="tests.test_readers.TestReadersEndpoints" name="test_get_readers" time="2.725"><error message="failed on setup with &quot;socket.gaierror: [Errno 11001] getaddrinfo failed&quot;">self = &lt;Coroutine test_get_readers&gt;

    def setup(self) -&gt; None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
&gt;       return super().setup()
               ^^^^^^^^^^^^^^^

.venv\Lib\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
                  ^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests\conftest.py:14: in setup_db
    async with engine.begin() as conn:
               ^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\contextlib.py:214: in __aenter__
    return await anext(self.gen)
           ^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:1066: in begin
    async with conn:
               ^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\base.py:121: in __aenter__
    return await self.start(is_ctxmanager=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:274: in start
    await greenlet_spawn(self.sync_engine.connect)
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3273: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3297: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:449: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:713: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:179: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:177: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:390: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:675: in __init__
    self.__connect()
.venv\Lib\site-packages\sqlalchemy\pool\base.py:901: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\base.py:897: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\create.py:646: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\default.py:625: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:961: in connect
    await_only(creator_fn(*arg, **kw)),
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connection.py:2421: in connect
    return await connect_utils._connect(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1075: in _connect
    raise last_error or exceptions.TargetServerAttributeNotMatched(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1049: in _connect
    conn = await _connect_addr(
.venv\Lib\site-packages\asyncpg\connect_utils.py:886: in _connect_addr
    return await __connect_addr(params, True, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:931: in __connect_addr
    tr, pr = await connector
             ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:802: in _create_ssl_connection
    tr, pr = await loop.create_connection(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1122: in create_connection
    infos = await self._ensure_resolved(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1508: in _ensure_resolved
    return await loop.getaddrinfo(host, port, family=family, type=type,
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:939: in getaddrinfo
    return await self.run_in_executor(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

host = 'db', port = 5432, family = 0, type = &lt;SocketKind.SOCK_STREAM: 1&gt;, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
&gt;       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       socket.gaierror: [Errno 11001] getaddrinfo failed

C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\socket.py:977: gaierror</error></testcase><testcase classname="tests.test_readers.TestReadersEndpoints" name="test_create_reader[John Doe-user@example.com-200]" time="2.690"><error message="failed on setup with &quot;socket.gaierror: [Errno 11001] getaddrinfo failed&quot;">self = &lt;Coroutine test_create_reader[John Doe-user@example.com-200]&gt;

    def setup(self) -&gt; None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
&gt;       return super().setup()
               ^^^^^^^^^^^^^^^

.venv\Lib\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
                  ^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests\conftest.py:14: in setup_db
    async with engine.begin() as conn:
               ^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\contextlib.py:214: in __aenter__
    return await anext(self.gen)
           ^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:1066: in begin
    async with conn:
               ^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\base.py:121: in __aenter__
    return await self.start(is_ctxmanager=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:274: in start
    await greenlet_spawn(self.sync_engine.connect)
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3273: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3297: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:449: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:713: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:179: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:177: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:390: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:675: in __init__
    self.__connect()
.venv\Lib\site-packages\sqlalchemy\pool\base.py:901: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\base.py:897: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\create.py:646: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\default.py:625: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:961: in connect
    await_only(creator_fn(*arg, **kw)),
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connection.py:2421: in connect
    return await connect_utils._connect(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1075: in _connect
    raise last_error or exceptions.TargetServerAttributeNotMatched(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1049: in _connect
    conn = await _connect_addr(
.venv\Lib\site-packages\asyncpg\connect_utils.py:886: in _connect_addr
    return await __connect_addr(params, True, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:931: in __connect_addr
    tr, pr = await connector
             ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:802: in _create_ssl_connection
    tr, pr = await loop.create_connection(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1122: in create_connection
    infos = await self._ensure_resolved(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1508: in _ensure_resolved
    return await loop.getaddrinfo(host, port, family=family, type=type,
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:939: in getaddrinfo
    return await self.run_in_executor(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

host = 'db', port = 5432, family = 0, type = &lt;SocketKind.SOCK_STREAM: 1&gt;, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
&gt;       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       socket.gaierror: [Errno 11001] getaddrinfo failed

C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\socket.py:977: gaierror</error></testcase><testcase classname="tests.test_readers.TestReadersEndpoints" name="test_create_reader[John Doe-user@example.com-409]" time="2.680"><error message="failed on setup with &quot;socket.gaierror: [Errno 11001] getaddrinfo failed&quot;">self = &lt;Coroutine test_create_reader[John Doe-user@example.com-409]&gt;

    def setup(self) -&gt; None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
&gt;       return super().setup()
               ^^^^^^^^^^^^^^^

.venv\Lib\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
                  ^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests\conftest.py:14: in setup_db
    async with engine.begin() as conn:
               ^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\contextlib.py:214: in __aenter__
    return await anext(self.gen)
           ^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:1066: in begin
    async with conn:
               ^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\base.py:121: in __aenter__
    return await self.start(is_ctxmanager=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:274: in start
    await greenlet_spawn(self.sync_engine.connect)
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3273: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3297: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:449: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:713: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:179: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:177: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:390: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:675: in __init__
    self.__connect()
.venv\Lib\site-packages\sqlalchemy\pool\base.py:901: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\base.py:897: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\create.py:646: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\default.py:625: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:961: in connect
    await_only(creator_fn(*arg, **kw)),
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connection.py:2421: in connect
    return await connect_utils._connect(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1075: in _connect
    raise last_error or exceptions.TargetServerAttributeNotMatched(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1049: in _connect
    conn = await _connect_addr(
.venv\Lib\site-packages\asyncpg\connect_utils.py:886: in _connect_addr
    return await __connect_addr(params, True, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:931: in __connect_addr
    tr, pr = await connector
             ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:802: in _create_ssl_connection
    tr, pr = await loop.create_connection(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1122: in create_connection
    infos = await self._ensure_resolved(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1508: in _ensure_resolved
    return await loop.getaddrinfo(host, port, family=family, type=type,
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:939: in getaddrinfo
    return await self.run_in_executor(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

host = 'db', port = 5432, family = 0, type = &lt;SocketKind.SOCK_STREAM: 1&gt;, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
&gt;       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       socket.gaierror: [Errno 11001] getaddrinfo failed

C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\socket.py:977: gaierror</error></testcase><testcase classname="tests.test_readers.TestReadersEndpoints" name="test_get_reader_by_id" time="2.703"><error message="failed on setup with &quot;socket.gaierror: [Errno 11001] getaddrinfo failed&quot;">self = &lt;Coroutine test_get_reader_by_id&gt;

    def setup(self) -&gt; None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
&gt;       return super().setup()
               ^^^^^^^^^^^^^^^

.venv\Lib\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
                  ^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests\conftest.py:14: in setup_db
    async with engine.begin() as conn:
               ^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\contextlib.py:214: in __aenter__
    return await anext(self.gen)
           ^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:1066: in begin
    async with conn:
               ^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\base.py:121: in __aenter__
    return await self.start(is_ctxmanager=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:274: in start
    await greenlet_spawn(self.sync_engine.connect)
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3273: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3297: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:449: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:713: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:179: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:177: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:390: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:675: in __init__
    self.__connect()
.venv\Lib\site-packages\sqlalchemy\pool\base.py:901: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\base.py:897: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\create.py:646: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\default.py:625: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:961: in connect
    await_only(creator_fn(*arg, **kw)),
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connection.py:2421: in connect
    return await connect_utils._connect(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1075: in _connect
    raise last_error or exceptions.TargetServerAttributeNotMatched(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1049: in _connect
    conn = await _connect_addr(
.venv\Lib\site-packages\asyncpg\connect_utils.py:886: in _connect_addr
    return await __connect_addr(params, True, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:931: in __connect_addr
    tr, pr = await connector
             ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:802: in _create_ssl_connection
    tr, pr = await loop.create_connection(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1122: in create_connection
    infos = await self._ensure_resolved(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1508: in _ensure_resolved
    return await loop.getaddrinfo(host, port, family=family, type=type,
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:939: in getaddrinfo
    return await self.run_in_executor(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

host = 'db', port = 5432, family = 0, type = &lt;SocketKind.SOCK_STREAM: 1&gt;, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
&gt;       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       socket.gaierror: [Errno 11001] getaddrinfo failed

C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\socket.py:977: gaierror</error></testcase><testcase classname="tests.test_readers.TestReadersEndpoints" name="test_delete_reader_correct" time="2.700"><error message="failed on setup with &quot;socket.gaierror: [Errno 11001] getaddrinfo failed&quot;">self = &lt;Coroutine test_delete_reader_correct&gt;

    def setup(self) -&gt; None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
&gt;       return super().setup()
               ^^^^^^^^^^^^^^^

.venv\Lib\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
                  ^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests\conftest.py:14: in setup_db
    async with engine.begin() as conn:
               ^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\contextlib.py:214: in __aenter__
    return await anext(self.gen)
           ^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:1066: in begin
    async with conn:
               ^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\base.py:121: in __aenter__
    return await self.start(is_ctxmanager=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:274: in start
    await greenlet_spawn(self.sync_engine.connect)
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3273: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3297: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:449: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:713: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:179: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:177: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:390: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:675: in __init__
    self.__connect()
.venv\Lib\site-packages\sqlalchemy\pool\base.py:901: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\base.py:897: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\create.py:646: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\default.py:625: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:961: in connect
    await_only(creator_fn(*arg, **kw)),
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connection.py:2421: in connect
    return await connect_utils._connect(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1075: in _connect
    raise last_error or exceptions.TargetServerAttributeNotMatched(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1049: in _connect
    conn = await _connect_addr(
.venv\Lib\site-packages\asyncpg\connect_utils.py:886: in _connect_addr
    return await __connect_addr(params, True, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:931: in __connect_addr
    tr, pr = await connector
             ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:802: in _create_ssl_connection
    tr, pr = await loop.create_connection(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1122: in create_connection
    infos = await self._ensure_resolved(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1508: in _ensure_resolved
    return await loop.getaddrinfo(host, port, family=family, type=type,
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:939: in getaddrinfo
    return await self.run_in_executor(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

host = 'db', port = 5432, family = 0, type = &lt;SocketKind.SOCK_STREAM: 1&gt;, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
&gt;       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       socket.gaierror: [Errno 11001] getaddrinfo failed

C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\socket.py:977: gaierror</error></testcase><testcase classname="tests.test_readers.TestReadersEndpoints" name="test_delete_reader_incorrect" time="2.714"><error message="failed on setup with &quot;socket.gaierror: [Errno 11001] getaddrinfo failed&quot;">self = &lt;Coroutine test_delete_reader_incorrect&gt;

    def setup(self) -&gt; None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
&gt;       return super().setup()
               ^^^^^^^^^^^^^^^

.venv\Lib\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
                  ^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
tests\conftest.py:14: in setup_db
    async with engine.begin() as conn:
               ^^^^^^^^^^^^^^
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\contextlib.py:214: in __aenter__
    return await anext(self.gen)
           ^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:1066: in begin
    async with conn:
               ^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\base.py:121: in __aenter__
    return await self.start(is_ctxmanager=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:274: in start
    await greenlet_spawn(self.sync_engine.connect)
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3273: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:3297: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:449: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:713: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:179: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\impl.py:177: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:390: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\pool\base.py:675: in __init__
    self.__connect()
.venv\Lib\site-packages\sqlalchemy\pool\base.py:901: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\pool\base.py:897: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\create.py:646: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\default.py:625: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:961: in connect
    await_only(creator_fn(*arg, **kw)),
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connection.py:2421: in connect
    return await connect_utils._connect(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1075: in _connect
    raise last_error or exceptions.TargetServerAttributeNotMatched(
.venv\Lib\site-packages\asyncpg\connect_utils.py:1049: in _connect
    conn = await _connect_addr(
.venv\Lib\site-packages\asyncpg\connect_utils.py:886: in _connect_addr
    return await __connect_addr(params, True, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:931: in __connect_addr
    tr, pr = await connector
             ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\connect_utils.py:802: in _create_ssl_connection
    tr, pr = await loop.create_connection(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1122: in create_connection
    infos = await self._ensure_resolved(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:1508: in _ensure_resolved
    return await loop.getaddrinfo(host, port, family=family, type=type,
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:939: in getaddrinfo
    return await self.run_in_executor(
C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

host = 'db', port = 5432, family = 0, type = &lt;SocketKind.SOCK_STREAM: 1&gt;, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
&gt;       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       socket.gaierror: [Errno 11001] getaddrinfo failed

C:\Users\yuraa\AppData\Local\Programs\Python\Python313\Lib\socket.py:977: gaierror</error></testcase></testsuite></testsuites>